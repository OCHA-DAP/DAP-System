/**
 *
 */
package org.ocha.hdx.importer;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.ocha.hdx.config.ConfigurationConstants;
import org.ocha.hdx.importer.helper.IndicatorTypeInformationHolder;
import org.ocha.hdx.model.validation.ValidationReport;
import org.ocha.hdx.model.validation.ValidationStatus;
import org.ocha.hdx.persistence.entity.configs.AbstractConfigEntry;
import org.ocha.hdx.persistence.entity.configs.IndicatorResourceConfigEntry;
import org.ocha.hdx.persistence.entity.configs.ResourceConfiguration;
import org.ocha.hdx.persistence.entity.curateddata.Indicator;
import org.ocha.hdx.validation.Response;
import org.ocha.hdx.validation.exception.WrongParametersForValidationException;
import org.ocha.hdx.validation.itemvalidator.IValidator;
import org.ocha.hdx.validation.itemvalidator.IValidatorCreator;
import org.ocha.hdx.validation.prevalidator.IPreValidator;
import org.ocha.hdx.validation.prevalidator.IPreValidatorCreator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * This class should be implemented by any importer class that needs to support the validation framework
 *
 * @author alexandru-m-g
 */
public abstract class AbstractValidatingImporter implements HDXWithCountryListImporter {

	private static Logger logger = LoggerFactory.getLogger(AbstractValidatingImporter.class);

	protected Map<String, AbstractConfigEntry> resourceEntriesMap;

	/**
	 * The key here will be indicator type code + source code
	 */
	protected Map<String, IndicatorTypeInformationHolder> infoPerIndicatorTypeMap;

	/**
	 * All existing validators. The key is the validator's name.
	 */
	private Map<String, IValidatorCreator> validatorCreatorsMap;

	/**
	 * All existing pre-validators. The key is the pre-validator's name.
	 */
	private Map<String, IPreValidator> preValidatorsMap;


	private final List<IPreValidator> preValidators;

	private final ValidationReport report;

	protected PreparedData preparedData;

	public AbstractValidatingImporter(final ResourceConfiguration resourceConfiguration, final List<IValidatorCreator> validatorCreators,
			final List<IPreValidatorCreator> preValidatorCreators, final ValidationReport report) {
		super();
		this.report = report;
		if (resourceConfiguration != null) {
			if (resourceConfiguration.getGeneralConfigEntries() != null) {
				this.generaterResourceEntriesMap(resourceConfiguration);
			}
			if (resourceConfiguration.getIndicatorConfigEntries() != null) {
				this.generateIndicatorEntriesMap(resourceConfiguration);
			} else {
				logger.warn("No indicator and source specific configuration found. No validation will be performed");

			}
		} else {
			logger.warn("No configuration found. No validation will be performed");
		}

		if (validatorCreators != null && validatorCreators.size() > 0) {
			this.validatorCreatorsMap = new HashMap<String, IValidatorCreator>();
			for (final IValidatorCreator validator : validatorCreators) {
				this.validatorCreatorsMap.put(validator.getValidatorName(), validator);
			}
		} else {
			logger.warn("There are no validators available.");
		}

		if (preValidatorCreators != null && preValidatorCreators.size() > 0) {
			this.preValidatorsMap	= new HashMap<String, IPreValidator>();
			for (final IPreValidatorCreator preValidatorCreator: preValidatorCreators) {
				try{
					this.preValidatorsMap.put(preValidatorCreator.getPreValidatorName(), preValidatorCreator.create(this.resourceEntriesMap));
				} catch (final WrongParametersForValidationException e) {
					logger.info( String.format("Pre-validator %s won't run because the necessary config is missing: %s",
							preValidatorCreator.getPreValidatorName(), e.getMessage()) );
				}
			}
		}

		this.preValidators	= this.findPreValidators();
	}

	private void generateIndicatorEntriesMap(final ResourceConfiguration resourceConfiguration) {
		if ( this.infoPerIndicatorTypeMap == null ) {
			this.infoPerIndicatorTypeMap	= new HashMap<String, IndicatorTypeInformationHolder>();
		}
		for (final IndicatorResourceConfigEntry indEntry : resourceConfiguration.getIndicatorConfigEntries()) {

			final String outerKey = this.generateMapKey( indEntry.getIndicatorType().getCode(), indEntry.getSource().getCode() );

			final IndicatorTypeInformationHolder indTypeInfoHolder = this.getIndTypeInfoHolder(outerKey);
			indTypeInfoHolder.getIndicatorEntries().put(indEntry.getEntryKey(), indEntry);
		}
	}

	/**
	 * @param key - key generated by {@link AbstractValidatingImporter#generateMapKey(String, String)}
	 * @return
	 */
	protected IndicatorTypeInformationHolder getIndTypeInfoHolder(final String key) {
		IndicatorTypeInformationHolder indTypeInfoHolder	= this.infoPerIndicatorTypeMap.get(key);
		if ( indTypeInfoHolder == null ) {
			indTypeInfoHolder	= new IndicatorTypeInformationHolder();
			this.infoPerIndicatorTypeMap.put(key, indTypeInfoHolder);
		}
		return indTypeInfoHolder;
	}

	private void generaterResourceEntriesMap(final ResourceConfiguration resourceConfiguration) {
		this.resourceEntriesMap = new HashMap<String, AbstractConfigEntry>();
		for (final AbstractConfigEntry entry : resourceConfiguration.getGeneralConfigEntries()) {
			this.resourceEntriesMap.put(entry.getEntryKey(), entry);
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.ocha.hdx.importer.HDXImporter#prepareDataForImport(java.io.File)
	 */
	@Override
	public PreparedData prepareDataForImport(final File file) {
		final List<PreparedIndicator> preparedIndicators = new ArrayList<>();
		final File valueFile = this.findValueFile(file);

		try (final BufferedReader br = new BufferedReader(new FileReader(valueFile))) {
			String line;
			while ((line = br.readLine()) != null) {
				try {
					final String[] values = this.getValuesFromLine(line);
					if (this.preValidation(values)) {
						final PreparedIndicator preparedIndicator = this.createPreparedIndicator(values);
						if ( preparedIndicator != null) {
							preparedIndicators.add(preparedIndicator);
						}
					}
				} catch (final RuntimeException re) {
					logger.warn(re.toString());
				}


			}

			this.preparedData	=  new PreparedData(true, preparedIndicators);
		} catch (final IOException e) {
			logger.debug(e.getMessage());
			this.preparedData	=  new PreparedData(true, preparedIndicators);
		}
		return this.preparedData;
	}

	protected boolean validation(final Indicator indicator) {
		boolean ret	= true;
		final List<IValidator> validators = this.findValidators(indicator);
		if (validators == null || validators.size() == 0) {
			logger.warn("No validators found for " + indicator);
		} else {
			for (final IValidator validator : validators) {
				final Response response = validator.validate(indicator);
				if (!this.verifyResponse(response)) {
					ret = false;
				}

			}
		}

		return ret;

	}

	private boolean verifyResponse(final Response response) {
		switch(response.getStatus()){
			case ERROR:
				this.report.addEntry(response.getStatus(), response.getDescription());
				return false;
			case WARNING:
				this.report.addEntry(response.getStatus(), response.getDescription());
				return true;
			default:
				return true;
		}
	}

	protected List<IPreValidator> findPreValidators() {
		final List<IPreValidator> retList	= new ArrayList<IPreValidator>();
		final AbstractConfigEntry entry	= this.resourceEntriesMap.get(ConfigurationConstants.PREVALIDATORS);
		if ( entry != null ) {
			final String [] preValidatorNames	= entry.getEntryValue().split(ConfigurationConstants.SEPARATOR);
			if (preValidatorNames != null) {
				for (final String name : preValidatorNames) {
					final IPreValidator preValidator	= this.preValidatorsMap.get(name);
					if ( preValidator != null ) {
						retList.add(preValidator);
					}
				}
			}
		}
		return retList;
	}

	protected List<IValidator> findValidators(final Indicator indicator) {
		final boolean sourceCodeNotEmpty = indicator.getSource() != null && indicator.getSource().getCode() != null;
		final boolean indicatorTypeCodeNotEmpty = indicator.getType() != null && indicator.getType().getCode() != null;

		if (sourceCodeNotEmpty && indicatorTypeCodeNotEmpty) {
			return this.cachedFindValidators(indicator.getType().getCode(), indicator.getSource().getCode());

		}
		return null;

	}

	protected List<IValidator> cachedFindValidators(final String indTypeCode, final String sourceCode) {
		if ( this.infoPerIndicatorTypeMap == null ) {
			this.infoPerIndicatorTypeMap	= new HashMap<String, IndicatorTypeInformationHolder>();
		}
		final String indAndSrcCode = this.generateMapKey(indTypeCode, sourceCode);
		final IndicatorTypeInformationHolder indTypeInfoHolder	= this.getIndTypeInfoHolder(indAndSrcCode);
		List<IValidator> cachedValidatorList = indTypeInfoHolder.getValidators();
		if (cachedValidatorList == null) {
			cachedValidatorList = new ArrayList<IValidator>();
			indTypeInfoHolder.setValidators(cachedValidatorList);

			/*
			 * Find configurations specific for this ind type and source pair
			 */
			final Map<String, AbstractConfigEntry> indConfigMap = indTypeInfoHolder.getIndicatorEntries();
			if (indConfigMap != null) {
				final AbstractConfigEntry validatorsEntry = indConfigMap.get(ConfigurationConstants.VALIDATORS);

				/*
				 * If there are validators configured to run, instantiate them
				 */
				if (validatorsEntry != null && validatorsEntry.getEntryValue() != null) {
					final String[] validatorNames = validatorsEntry.getEntryValue().split(ConfigurationConstants.SEPARATOR);
					if (validatorNames != null) {
						for (final String name : validatorNames) {
							final IValidatorCreator validatorCreator = this.validatorCreatorsMap.get(name);
							if (validatorCreator != null) {
								try {
									cachedValidatorList.add(validatorCreator.create(this.resourceEntriesMap, indConfigMap));
								} catch (final WrongParametersForValidationException e) {
									logger.info( String.format("Validator %s won't run for indicator type %s and source %s because the necessary config is missing: %s",
											indTypeCode, sourceCode, validatorCreator.getValidatorName(), e.getMessage()) );
								}
							} else {
								logger.warn("No validator found for name " + name);
							}
						}
					}
				} else {
					logger.warn("No validators configured for this ind type and source pair: " + indAndSrcCode);
				}
			} else {
				logger.warn("No configuration found for this ind type and source pair:" + indAndSrcCode);
			}

			if ( cachedValidatorList.size() == 0 ) {
				this.report.addEntry(ValidationStatus.WARNING,
						String.format("No validators found for indicator type '%s' and source '%s'", indTypeCode, sourceCode));
			}
		}
		return cachedValidatorList;
	}

	protected boolean preValidation(final String[] values) {
		boolean ret = true;
		for (final IPreValidator preValidator : this.preValidators) {
			final Response response = preValidator.validate(values);
			if (! this.verifyResponse(response) ) {
				ret	= false;
			}
		}
		return ret;
	}

	/**
	 * @param indTypeCode
	 * @param sourceCode
	 * @return
	 */
	protected String generateMapKey(final String indTypeCode, final String sourceCode) {
		final String indAndSrcCode = indTypeCode + sourceCode;
		return indAndSrcCode;
	}

	protected abstract String[] getValuesFromLine(final String line);

	protected abstract File findValueFile(File file);

	protected abstract PreparedIndicator createPreparedIndicator(String[] values);

}
